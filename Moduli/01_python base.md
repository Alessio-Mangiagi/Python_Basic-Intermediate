# - python base -

### Giorno 1
- **Teoria: Introduzione a Python**

1. Titolo e obiettivi della lezione
2. Cos'è Python e perché impararlo
3. Storia del linguaggio e comunità
4. Installazione di Python su diversi sistemi operativi
5. Cos'è il REPL e come usarlo
6. Scelta di un IDE: focus su Visual Studio Code
7. Creazione e salvataggio di uno script Python (estensioni dei file)
8. Struttura base di uno script Python
9. Convenzioni di stile (PEP8)
10. Commenti e documentazione inline
11. Panoramica sulla sintassi: indentazione e blocchi
12. Esecuzione da terminale vs IDE
13. Differenze tra script e moduli
14. Risorse ufficiali e comunità online
15. Riepilogo e domande frequenti

- **Pratica: Primo Contatto con Python**

1. Setup ambiente e test REPL
2. Esercizio: stampa "Hello, World!"
3. Uso di print() con stringhe, numeri
4. Inserimento di input da tastiera con input()
5. Conversione tipi: int(), float(), str()
6. Concatenazione e formattazione stringhe
7. Esercizio: calcolo area di un rettangolo
8. Esercizio: input nome e stampa messaggio personalizzato
9. Debugging base: errori comuni (SyntaxError, NameError)
10. Uso di variabili
11. Salvataggio ed esecuzione di script
12. Organizzazione dei file
13. Commenti e buona leggibilità del codice
14. Breve quiz su quanto appreso
15. Preparazione al giorno 2

---

### Giorno 2
-  **Teoria: Tipi Primitivi e Operatori**
     
1. Obiettivi della lezione
2. Tipi primitivi: int, float, str, bool
3. Differenze e conversioni tra tipi
4. Operatori aritmetici: +, -, *, /, %, //, **
5. Operatori di confronto: ==, !=, <, >, <=, >=
6. Operatori logici: and, or, not
7. Precedenza degli operatori
8. Assegnazione e aggiornamento variabili
9. Costanti e nomi significativi
10. Formattazione di stringhe (f-string)
11. Casting tra tipi
12. Uso di `type()` per verificare tipi
13. Errori comuni: divisione per zero, tipo non supportato
14. Riepilogo pratico con esempi
15. Domande e confronto

- **Pratica: Calcoli e Stringhe**

1. Calcolatrice: somma, sottrazione, moltiplicazione, divisione
2. Esercizio: calcolo area e perimetro di figure geometriche
3. Esercizio: conversione di temperature
4. Uso di input() per acquisizione valori numerici
5. Conversioni tipo float/int
6. Concatenazione stringhe e uso di f-string
7. Esercizio: saluto personalizzato con nome e età
8. Calcolo media aritmetica di tre numeri
9. Operazioni combinate con operatori
10. Uso di `round()` e `abs()`
11. Interazione tra variabili di tipi diversi
12. Debugging esercizi
13. Quiz a scelta multipla interattivo
14. Confronto tra stringhe: ==, !=
15. Riepilogo esercizi svolti

---

### Giorno 3
- **Teoria: Strutture di Controllo e Cicli**

1. Obiettivi lezione
2. if, elif, else: struttura e logica
3. Condizioni multiple e annidate
4. Esercizi mentali di logica booleana
5. Cicli for: iterazione su range e collezioni
6. Cicli while: uso e rischi di loop infiniti
7. Uso di break e continue
8. Pass come placeholder
9. Range: sintassi e step personalizzati
10. Enumerare oggetti
11. Nesting: condizioni dentro cicli e viceversa
12. Buone pratiche con indentazione
13. Simulazione logiche decisionali
14. Esempi con numeri, stringhe e condizioni
15. Riepilogo e FAQ

- **Pratica: Controlli e Ripetizioni**

1. Esercizio: determinare se un numero è pari o dispari
2. Esercizio: calcolo del massimo tra tre numeri
3. Stampa dei primi N numeri
4. Somma dei numeri da 1 a N con for
5. Uso del ciclo while per contare al contrario
6. Esercizio: tabellina del numero inserito
7. Ricerca in una lista: presenza elemento
8. Calcolo media e numero massimo da lista input
9. Contatore con ciclo e condizione
10. Esercizio: identificazione numeri primi
11. Stampa solo numeri pari da 1 a 100
12. Nested loop: tabella moltiplicazioni
13. Validazione input con while
14. Debugging: infinite loop e condizioni errate
15. Riflessione e confronto soluzioni

---

### Giorno 4
- **Teoria: Funzioni, Moduli e Namespace**

1. Cosa sono le funzioni
2. Definizione di funzione con def
3. Parametri e argomenti
4. Valori di ritorno con return
5. Scope: variabili locali e globali
6. Documentazione funzioni (docstring)
7. Buone pratiche di naming e modularità
8. Funzioni built-in di Python
9. Creazione di moduli personalizzati
10. Import di moduli standard (math, random)
11. Differenza tra import e from-import
12. Gestione del namespace
13. Condizione `if __name__ == "__main__"`
14. Uso di help() per moduli e funzioni
15. Riepilogo con esempi

- **Pratica: Funzioni e Moduli**

1. Scrittura di funzioni semplici (somma, fattoriale, media)
2. Funzione per determinare se numero è pari o dispari
3. Uso di return per inviare valore al chiamante
4. Parametri con valori predefiniti
5. Funzioni che accettano stringhe e restituiscono modifiche
6. Funzione che calcola sconto su prezzo
7. Creazione di un modulo personale utils.py
8. Import di moduli math e random
9. Simulazione di lancio dadi e generatore numeri casuali
10. Import multiplo e alias
11. Uso di variabili globali all’interno di funzione
12. Test di funzioni con valori diversi
13. Documentazione e help() su moduli
14. Esercizio finale di refactoring con funzioni
15. Preparazione a strutture dati

---

### Giorno 5
- **Teoria: Strutture dati: Liste, Tuple, Dizionari, Set**

1. Introduzione alle strutture dati in Python  
2. Liste: definizione e caratteristiche  
3. Operazioni principali sulle liste (`append`, `remove`, `indexing`, `slicing`)  
4. Liste: metodi utili (`sort`, `reverse`, `count`, `index`)  
5. Comprensioni di lista (list comprehension)  
6. Tuple: caratteristiche e differenze con le liste  
7. Operazioni e utilizzi delle tuple  
8. Dizionari: definizione e utilizzo base  
9. Metodi e operazioni comuni sui dizionari (`keys`, `values`, `items`)  
10. Aggiornare e rimuovere elementi nei dizionari  
11. Set: definizione e caratteristiche  
12. Operazioni fondamentali con i set (unione, intersezione, differenza)  
13. Quando usare liste, tuple, dizionari o set  
14. Performance e mutabilità delle strutture dati  
15. Esercizio teorico: scegliere la struttura dati corretta per uno scenario  

- **Pratica: Manipolazione di collezioni** 

1. Creare una lista di numeri casuali  
2. Ordinare e filtrare una lista  
3. Conteggio frequenze in una lista (es. lettere o numeri)  
4. Utilizzo di list comprehension  
5. Conversione tra tipi di collezioni (`list` ↔ `set` ↔ `tuple`)  
6. Rimozione dei duplicati usando i `set`  
7. Creare un dizionario da due liste (`zip` + `dict`)  
8. Accesso e modifica di elementi in un dizionario  
9. Verifica della presenza di chiavi/valori  
10. Dizionari annidati: creazione e aggiornamento  
11. Set: gestione di insiemi di parole da una frase  
12. Creare un dizionario con conteggio parole  
13. Analisi frequenze da un testo  
14. Debugging: errori comuni con strutture mutabili  
15. Quiz finale pratico (scelte multiple / codice incompleto)  

---

### Giorno 6
- **Teoria: Gestione file e gestione delle eccezioni**

1. Introduzione alla gestione dei file  
2. Il costrutto `open()` e le modalità (`'r'`, `'w'`, `'a'`, `'x'`)  
3. Lettura file (`read`, `readline`, `readlines`)  
4. Scrittura file (`write`, `writelines`)  
5. Uso del `with` per apertura sicura  
6. Codifica dei file (`utf-8`, ecc.)  
7. File CSV: struttura e utilizzo  
8. Modulo `csv`: lettura e scrittura base  
9. Introduzione alle eccezioni in Python  
10. Blocco `try/except`  
11. Gestione di più eccezioni  
12. Blocchi `else` e `finally`  
13. Tipi comuni di errori (`ValueError`, `FileNotFoundError`, ecc.)  
14. Buone pratiche nella gestione degli errori  
15. Analisi codice con gestione errori  

- **Pratica – File e gestione errori**

1. Lettura di un file di testo  
2. Scrivere contenuti su un file  
3. Contare righe, parole e caratteri di un file  
4. Lettura sicura con `with`  
5. Lettura file CSV con `csv.reader`  
6. Scrittura file CSV con `csv.writer`  
7. Parsing CSV in dizionari  
8. CSV → elenco di dizionari  
9. Introduzione errore e gestione con `try/except`  
10. Gestione `FileNotFoundError`  
11. Validazione input da file  
12. Logging semplice su file  
13. Calcolare media da file con errori  
14. Simulazione lettura/scrittura logica  
15. Debug finale  

---

### Giorno 7
- **Teoria: Programmazione a oggetti (classi, oggetti, ereditarietà)**

1. Introduzione alla OOP  
2. Procedurale vs orientata agli oggetti  
3. Definizione di una classe  
4. Istanziare oggetti  
5. Attributi di istanza e metodi  
6. Metodo `__init__()`  
7. Attributi di classe vs istanza  
8. Metodi speciali (`__str__`, `__repr__`, ecc.)  
9. Incapsulamento: `_attributo`  
10. Ereditarietà: concetti base  
11. Classe genitore e sottoclasse  
12. Override di metodi  
13. Uso di `super()`  
14. Composizione vs ereditarietà  
15. Progettare classi da specifiche  

- **Pratica: Mini-progetto OOP**

1. Classe `Persona` con attributi  
2. Metodo `saluta()` personalizzato  
3. Creare più oggetti  
4. Sottoclasse `Studente`  
5. Override metodo `saluta()`  
6. Estendere `__init__` con `super()`  
7. Aggiunta attributi a `Studente`  
8. Classe `Corso` con elenco studenti  
9. Metodo per iscrivere studenti  
10. Metodo per stampare iscritti  
11. Classe `Docente` con metodi specifici  
12. Esercizio: gestione scuola  
13. (Facoltativo) Salvataggio con `pickle`  
14. Debug OOP  
15. Presentazione mini-progetto  

---

### Giorno 8
- **Teoria: Virtualenv, pip, packaging**

1. Introduzione agli ambienti virtuali  
2. Perché usare ambienti virtuali  
3. Creazione virtualenv con `venv`  
4. Attivazione/disattivazione ambiente  
5. Introduzione a `pip`  
6. Installare pacchetti da PyPI  
7. `requirements.txt`: creazione e scopo  
8. `pip install` vs `pip freeze`  
9. Panoramica sul packaging  
10. Struttura pacchetto Python (`__init__.py`)  
11. Introduzione a `setup.py`  
12. Import di moduli esterni  
13. Gestione dipendenze nei progetti  
14. Buone pratiche virtualenv  
15. Q&A finale  

- **Pratica: Ambiente virtuale e dipendenze**

1. Creazione progetto con cartelle  
2. Creazione e attivazione virtualenv  
3. Installazione pacchetti (`requests`, `pandas`, ecc.)  
4. Test pacchetti installati  
5. Disinstallazione e pulizia  
6. `pip freeze > requirements.txt`  
7. Ricreare ambiente da `requirements.txt`  
8. Script che usa pacchetto esterno  
9. Struttura moduli in progetto  
10. Analisi CSV con `pandas`  
11. Creazione semplice pacchetto  
12. Debug ambiente virtuale  
13. Progetto finale con dipendenze  
14. Accenno a Git/versionamento  
15. Condivisione ambiente  